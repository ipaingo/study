# Вариант 1.4
### Условие задачи
Напишите программу формирования цифровой подписи алгоритмом RSA. Рекомендуется использовать библиотеку для работы с длинными числами. В случае применения этой библиотеки разрешается использовать функции сложения, вычитания, умножения, целочисленного деления, вычисления остатка от деления. Функции возведения числа в степень, нахождения наибольшего общего делителя, обратного элемента в мультипликативной группе вычетов, генерации простого числа реализовать самостоятельно. Выполняемые функции программы:
1) генерация пары открытый/закрытый ключ, при этом число e задается пользователем;
2) получения цифровой подписи для сообщения (целого числа);
3) проверки цифровой подписи для данного сообщения (целого числа).

### Метод решения
Задача решается написанием алгоритма RSA на языке C#. Для генерации псевдопростых чисел используется тест Миллера-Рабина. Для нахождения секретной экспоненты используется расширенный алгоритм Евклида.

### Код решения
```C#
using System.Numerics;
using System;

BigInteger BinPow(BigInteger n, BigInteger k, BigInteger mod) {
    if (k == 0)
        return new BigInteger(1);
    if (k == 1)
        return n % mod;

    var mid = BinPow(n, k / 2, mod);
    return mid * mid * (k % 2 == 1 ? n : 1) % mod;
}

List<int> generateLowPrimes() {
    bool[] sieve = new bool[2000];
    for (int i = 2; i < 2000; i++) {
        if (!sieve[i]) {
            for (int j = i * i; j < 2000; j += i) {
                sieve[j] = true;
            }
        }
    }

    var primes = new List<int>();
    for (int i = 2; i < 2000; i++) {
        if (!sieve[i]) {
            primes.Add(i);
        }
    }

    return primes;
}

var lowPrimes = generateLowPrimes();

bool isMayBePrime(BigInteger prime) {
    foreach (var lp in lowPrimes) {
        if (lp == prime)
            return true;
        if (prime % lp == 0) {
            return false;
        }
    }

    int s = 0;
    BigInteger t = prime - 1;
    while (t % 2 == 0) {
        t /= 2;
        s++;
    }

    int iters = 256;
    while (iters-- > 0) {
        var a = RandBigIntegerInRange(2, prime - 2);
        var x = BinPow(a, t, prime);
        if (x == 1 || x == prime - 1)
            continue;

        bool flag = true;
        for (int i = 1; i < s; i++) {
            x = BinPow(x, 2, prime);
            if (x == 1)
                return false;
            if (x == prime - 1) {
                flag = false;
                break;
            }
        }
        if (flag) {
            return false;
        }
    }

    return true;
}

BigInteger getRandomPrime() {
    while (true) {
        int bits = 256;
        BigInteger min = 1, max = 2;
        while (--bits > 0) {
            min *= 2;
            max *= 2;
        }
        min++;
        max--;
        var prime = RandBigIntegerInRange(min, max);
        if (prime % 2 == 0)
            prime += 1;
        if (!isMayBePrime(prime))
            continue;
        return prime;
    }
}


BigInteger GCD(BigInteger a, BigInteger b) {
    if (b > a)
        (a, b) = (b, a);
    while (b > 0) {
        a %= b;
        (a, b) = (b, a);
    }

    return a;
}

BigInteger GCDex(BigInteger a, BigInteger b, out BigInteger x, out BigInteger y) {
	if (a == 0) {
		x = 0; y = 1;
		return b;
	}
	BigInteger x1, y1;
	BigInteger d = GCDex(b % a, a, out x1, out y1);
	x = y1 - (b / a) * x1;
	y = x1;
	return d;
}

void generateRSAKeys(BigInteger e, out BigInteger d, out BigInteger n) {
    BigInteger p, q, f;
    do {
        p = getRandomPrime();
        q = getRandomPrime();
        n = p * q;
        f = (p - 1) * (q - 1);
    } while (GCD(e, f) != 1);
    GCDex(e, f, out d, out BigInteger y);
    d = (d % f + f) % f;
}

BigInteger getCert(in BigInteger m, in BigInteger d, in BigInteger n) {
    return BinPow(m, d, n);
}

bool validateCert(in BigInteger m, in BigInteger cert, in BigInteger e, BigInteger n) {
    return m == BinPow(cert, e, n);
}


BigInteger m = 1111;
BigInteger e = 1337;
BigInteger n, d;
generateRSAKeys(e, out d, out n);

Console.WriteLine($"({n}, {d})");
Console.WriteLine($"({n}, {e})");

var cert = getCert(m, d, n);

Console.WriteLine(cert);

if (validateCert(m, cert, e, n)) {
    Console.WriteLine("Valid");
} else {
    Console.WriteLine("Invalid");
}

if (validateCert(m, cert + 4, e, n)) {
    Console.WriteLine("Valid");
} else {
    Console.WriteLine("Invalid");
}

```

### Пример решения
```
bits = 256
message = 1111
e = 1337
(n, d) = (7318615361439484707676073878806196227745241470436861512832753592925728888951215403994834858261904244784832033666429699439961820237754709573575679574496847, 2348306649257695541954402164553371863651988474807340006735416074319474714554971365055261611061552113579578504647492944721634248899013615428712545549557713)
cert = 3132649084202572815796258686268061872629672180540491473339138121176141745184732193763031375221954611763528318797573292389293064790360599515617576168520243
```
